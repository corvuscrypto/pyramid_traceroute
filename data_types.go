package pyramidtrace

//list of scopes in "memory"
var scopeStack = []string{}

//list of all scopes generated by the route
var routeScopes = map[string]*scope{}

type scopeType int
type subTreeNode struct {
	Depth int
	Name  string
}

var circularRef = &scope{
	sError,
	"",
	nil,
	nil,
	false,
}

const (
	sGlobal scopeType = iota
	sFunction
	sClass
	sError
)

type scope struct {
	Type      scopeType
	Name      string
	Members   []*scope
	MemberMap map[string]int
	inPath    bool
}

func CreateScope(t int, n string) *scope {
	return &scope{
		scopeType(t),
		n,
		[]*scope{},
		make(map[string]int),
		false,
	}
}

func (s *scope) AddChild(c *scope) {
	s.Members = append(s.Members, c)
	s.MemberMap[c.Name] = len(s.Members) - 1
}

func (s *scope) hasMember(name string) bool {
	_, exists := s.MemberMap[name]
	return exists
}

func (s *scope) GetMemberTree() string {
	var prefix = "|__"
	var padding = ""
	var result = ""
	var depth = 0
	for _, v := range s.walk(0) {
		if v.Depth < depth {
			padding = padding[3:]
			result += "\r\n"
		} else if v.Depth > depth {
			padding = padding + "   "
		}
		depth = v.Depth
		result += padding + prefix + v.Name + "\r\n"
	}
	return result
}

func (s *scope) walk(depth int) []subTreeNode {
	if s.inPath {

	}
	var subTArray = []subTreeNode{}
	var subT = subTreeNode{depth, ""}
	if s.inPath {
		subT.Name = "Circular Ref to: " + s.Name
		return append(subTArray, subT)
	}
	s.inPath = true
	subT.Name = s.Name
	subTArray = append(subTArray, subT)
	for _, v := range s.Members {
		subTArray = append(subTArray, v.walk(depth+1)...)
	}
	s.inPath = false
	return subTArray
}
